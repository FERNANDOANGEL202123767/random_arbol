from flask import Flask, jsonify, request, render_template
from flask_cors import CORS
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import RobustScaler, LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score, f1_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeClassifier, plot_tree
from pandas import DataFrame
import matplotlib.pyplot as plt
import io
import base64
import os
import logging

# Configuración del logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)

# Función para dividir el dataset en conjuntos de entrenamiento, validación y prueba
def train_val_test_split(df, rstate=42, shuffle=True, stratify=None):
    strat = df[stratify] if stratify else None
    train_set, test_set = train_test_split(
        df, test_size=0.4, random_state=rstate, shuffle=shuffle, stratify=strat)
    strat = test_set[stratify] if stratify else None
    val_set, test_set = train_test_split(
        test_set, test_size=0.5, random_state=rstate, shuffle=shuffle, stratify=strat)
    return (train_set, val_set, test_set)

# Función para separar características y etiquetas
def remove_labels(df, label_name):
    X = df.drop(label_name, axis=1)
    y = df[label_name].copy()
    return (X, y)

# Ruta principal: Renderiza el HTML para el cliente
@app.route('/')
def index():
    return render_template('index.html')

# Ruta para visualizar un árbol de decisión
@app.route('/decision_tree', methods=['GET'])
def decision_tree():
    try:
        logger.info("Starting decision tree visualization")
        
        # Cargar el dataset localmente
        logger.info("Loading dataset")
        try:
            data = pd.read_csv('data/archivo_reducido.csv')
            logger.info("Dataset loaded successfully")
        except FileNotFoundError as file_error:
            logger.error(f"Dataset file not found: {file_error}")
            return jsonify({'error': 'Dataset file not found'}), 404
        except Exception as load_error:
            logger.error(f"Error loading dataset: {load_error}")
            return jsonify({'error': str(load_error)}), 500

        # Seleccionar características
        X_train = data[['min_flowpktl', 'flow_fin']]
        y_train = data['calss']

        # Codificar etiquetas
        logger.info("Encoding labels")
        label_encoder = LabelEncoder()
        y_train_encoded = label_encoder.fit_transform(y_train)

        # Entrenar árbol de decisión
        logger.info("Training decision tree")
        try:
            clf_tree_reduced = DecisionTreeClassifier(random_state=42)
            clf_tree_reduced.fit(X_train, y_train_encoded)
            logger.info("Decision tree trained successfully")
        except Exception as train_error:
            logger.error(f"Error training decision tree: {train_error}")
            return jsonify({'error': str(train_error)}), 500

        # Graficar el árbol de decisión
        logger.info("Generating decision tree visualization")
        try:
            plt.figure(figsize=(20, 10))
            plot_tree(clf_tree_reduced, 
                      filled=True, 
                      feature_names=['min_flowpktl', 'flow_fin'], 
                      class_names=label_encoder.classes_.tolist(),
                      rounded=True,
                      fontsize=10)
            
            img_buffer = io.BytesIO()
            plt.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
            img_buffer.seek(0)
            plt.close()
            
            img_base64 = base64.b64encode(img_buffer.getvalue()).decode('utf-8')
            logger.info("Decision tree visualization generated successfully")
            
            return jsonify({
                'message': 'Árbol de decisión exportado!', 
                'image': img_base64
            })
        except Exception as viz_error:
            logger.error(f"Error generating decision tree visualization: {viz_error}")
            return jsonify({'error': str(viz_error)}), 500

    except Exception as e:
        logger.error(f"Unexpected error in decision_tree route: {e}")
        return jsonify({"error": str(e)}), 500

# Ruta para cargar datos dinámicamente
@app.route('/upload_data', methods=['POST'])
def upload_data():
    if 'file' not in request.files:
        logger.error("No file part in the request")
        return jsonify({'error': 'No file provided'}), 400
    file = request.files['file']
    if file.filename == '':
        logger.error("No selected file")
        return jsonify({'error': 'No file selected'}), 400
    try:
        data = pd.read_csv(file)
        logger.info("File uploaded and read successfully")
        return jsonify({'message': 'File uploaded successfully', 'columns': data.columns.tolist()})
    except Exception as e:
        logger.error(f"Error processing uploaded file: {e}")
        return jsonify({'error': str(e)}), 500

# Ruta para entrenar un modelo Random Forest
@app.route('/train_random_forest', methods=['POST'])
def train_random_forest():
    try:
        request_data = request.get_json()
        features = request_data.get('features')
        label = request_data.get('label')
        if not features or not label:
            return jsonify({'error': 'Features and label are required'}), 400

        # Cargar el dataset localmente
        data = pd.read_csv('data/archivo_reducido.csv')
        X = data[features]
        y = data[label]

        # Escalar características
        scaler = RobustScaler()
        X_scaled = scaler.fit_transform(X)

        # Dividir los datos
        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

        # Entrenar modelo
        model = RandomForestRegressor(random_state=42)
        model.fit(X_train, y_train)

        # Evaluar modelo
        y_pred = model.predict(X_test)
        mse = mean_squared_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)

        return jsonify({
            'message': 'Modelo entrenado exitosamente',
            'mse': mse,
            'r2_score': r2
        })
    except Exception as e:
        logger.error(f"Error training Random Forest model: {e}")
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 5000))
    app.run(host='0.0.0.0', port=port, debug=True)
